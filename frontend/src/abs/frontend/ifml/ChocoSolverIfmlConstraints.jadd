import abs.frontend.ifml.ChocoSolverIfml;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.solver.variables.BoolVar;
import org.chocosolver.solver.expression.discrete.arithmetic.ArExpression;
import abs.frontend.ast.IfmlBoundaryInt;

aspect ChocoSolverIfmlConstraints {

    public ChocoSolverIfml Model.instantiateCS4Model() {
    	ChocoSolverIfml cs = new ChocoSolverIfml();

    	// adding int variables to choco solver
        // new int variable for all int variables
        for (java.util.Map.Entry<String, IfmlBoundaryInt[]> entry : ifmlints().entrySet()) {
            String st = entry.getKey();
            if (entry.getValue().length == 2) {
                IfmlBoundaryInt b1 = entry.getValue()[0];
                IfmlBoundaryInt b2 = entry.getValue()[1];
                cs.addBoundedVar(st, b1, b2);
            } else {
                cs.addIntVarWithSetDomain(st, entry.getValue());
            }
        }
        // adding bool variables to choco solver
        for (String st : ifmlbools())
            cs.addBoolVar(st);
        // adding feature variables to choco solver
        for (String st : ifmlfeatures())
            cs.addBoolVar(st);
        // adding group names to choco solver
        for (String st : ifmlgroups())
            cs.addBoolVar(st);
        // adding constraint names to choco solver
        for(String st : ifmlconstraints())
			cs.addBoolVar(st);
        // adding string variables to choco solver
        for(String st : ifmlstrings())
			cs.addBoolVar(st);

        return cs;
    }
		
    // REQUIRES
    public void IfmlRequires.addIfmlConstraints(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
	    IntVar[] featureVars = cs4model.retrieveIntVars(true);
    	org.chocosolver.solver.constraints.Constraint c1 = null;
    	if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(parentName())) {
    		// parent is feature
    		IntVar featVar = cs.getVar(parentName());
    		c1 = cs4model.arithm(featVar,"=",1);
    	} else {
    		// parent is group
    		IfmlGroupDecl ifmlGroupDecl = ((Model)calcContextNode(Model.class)).getIfmlGroupDeclByGroupName(parentName());
    		BoolVar[] featVarsInGroup = cs.getAllFeaturesInGroup(ifmlGroupDecl);
    		c1 = cs4model.or(featVarsInGroup);
    	}
    	BoolVar c1_bool = c1.reify();
    	for(int i=0;i<getNumIfmlFeatVar();i++){
	        String featName = getIfmlFeatVar(i).getIfmlFName();
	        for(IntVar featureVar : featureVars){
	            if(featureVar.getName().equals(featName)) {
	            	org.chocosolver.solver.constraints.Constraint c2 = cs4model.arithm(featureVar,"=",1);
	            	BoolVar c2_bool = c2.reify();
	            	org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(c1_bool,"<=", c2_bool);
	            	cstr.setName(parentName()+" requires "+featName);
	                cs.addConstraint(cstr);
	            }
	        }
	    }
    }

    // EXCLUDES
    public void IfmlExcludes.addIfmlConstraints(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
	    IntVar[] featureVars = cs4model.retrieveIntVars(true);
    	org.chocosolver.solver.constraints.Constraint c1 = null;
    	if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(parentName())) {
    		// parent is feature
    		IntVar featVar = cs.getVar(parentName());
    		c1 = cs4model.arithm(featVar,"=",1);
    	} else {
    		// parent is group
    		IfmlGroupDecl ifmlGroupDecl = ((Model)calcContextNode(Model.class)).getIfmlGroupDeclByGroupName(parentName());
    		BoolVar[] featVarsInGroup = cs.getAllFeaturesInGroup(ifmlGroupDecl);
    		c1 = cs4model.or(featVarsInGroup);
    	}
    	BoolVar c1_bool = c1.reify();
    	for(int i=0;i<getNumIfmlFeatVar();i++){
	        String featName = getIfmlFeatVar(i).getIfmlFName();
	        for(IntVar featureVar : featureVars){
	            if(featureVar.getName().equals(featName)) {
	            	org.chocosolver.solver.constraints.Constraint c2 = cs4model.arithm(featureVar,"=",0);
	            	BoolVar c2_bool = c2.reify();
	            	org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(c1_bool,"<=", c2_bool);
	            	cstr.setName(parentName()+" excludes "+featName);
	                cs.addConstraint(cstr);
	            }
	        }
	    }
    }

    // IFIN
    public void IfmlIfIn.addIfmlConstraints(ChocoSolverIfml cs,org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint c1 = null;
    	if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(parentName())) {
    		// parent is feature
    		IntVar featVar = cs.getVar(parentName());
    		c1 = cs4model.arithm(featVar,"=",1);
    	} else {
    		// parent is group
    		IfmlGroupDecl ifmlGroupDecl = ((Model)calcContextNode(Model.class)).getIfmlGroupDeclByGroupName(parentName());
    		BoolVar[] featVarsInGroup = cs.getAllFeaturesInGroup(ifmlGroupDecl);
    		c1 = cs4model.or(featVarsInGroup);
    	}    	
    	
        org.chocosolver.solver.constraints.Constraint c2 = getIfmlExpr().collectIfmlConstraints(cs, cs4model);
    	BoolVar c1_bool = c1.reify();
    	BoolVar c2_bool = c2.reify();
    	org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(c1_bool,"<=", c2_bool);
    	cstr.setName(parentName()+" ifin "+c2.getName());
        cs.addConstraint(cstr);
    }
    
    // IfOUT
    public void IfmlIfOut.addIfmlConstraints(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint c1 = null;
    	if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(parentName())) {
    		// parent is feature
    		IntVar featVar = cs.getVar(parentName());
    		c1 = cs4model.arithm(featVar,"=",0);
    	} else {
    		// parent is group
    		IfmlGroupDecl ifmlGroupDecl = ((Model)calcContextNode(Model.class)).getIfmlGroupDeclByGroupName(parentName());
    		BoolVar[] featVarsInGroup = cs.getAllFeaturesInGroup(ifmlGroupDecl);
    		c1 = cs4model.not(cs4model.or(featVarsInGroup));
    	}    	
    	
        org.chocosolver.solver.constraints.Constraint c2 = getIfmlExpr().collectIfmlConstraints(cs, cs4model);
    	BoolVar c1_bool = c1.reify();
    	BoolVar c2_bool = c2.reify();
    	org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(c1_bool,"<=", c2_bool);
    	cstr.setName(parentName()+" ifout "+c2.getName());
        cs.addConstraint(cstr);
    }
    
    // IfmlAllOf (allof)
    public void IfmlAllOf.addCardinalityConstraint(BoolVar[] allFeaturesInGroup, String groupName, 
    		ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
      // Every group must have atleast one feature
    	org.chocosolver.solver.constraints.Constraint allof = cs4model.sum(allFeaturesInGroup, "=" , allFeaturesInGroup.length);
    	allof.setName("Cardinality '"+cs.IFMLCONSTRAINT_ALLOF+"' for "+groupName+" "+allof.toString());
        cs.addConstraint(allof);
    }
    
    // IfmlMinim ([from..*])
    public void IfmlMinim.addCardinalityConstraint(BoolVar[] allFeaturesInGroup, String groupName, 
    		ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint minimCstr = cs4model.sum(allFeaturesInGroup, ">=" , getIfmlCFrom());
        minimCstr.setName("Cardinality '"+"["+getIfmlCFrom()+"..*]"+"' for "+groupName+" "+minimCstr.toString());
        cs.addConstraint(minimCstr);
    }
    
    // IfmlCRange (incl. oneof and [from..to])
    public void IfmlCRange.addCardinalityConstraint(BoolVar[] allFeaturesInGroup, String groupName, 
    		ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        if(getIfmlCFrom() == 1 && getIfmlCTo() == 1){
            //Apply oneof cardinality
        	org.chocosolver.solver.constraints.Constraint oneof = cs4model.sum(allFeaturesInGroup, "=" , 1);
            oneof.setName("Cardinality '"+cs.IFMLCONSTRAINT_ONEOF+"' for "+groupName+" "+oneof.toString());
            cs.addConstraint(oneof);
        } else {
            //Apply [From..To] cardinality
            org.chocosolver.solver.constraints.Constraint fromCstr = cs4model.sum(allFeaturesInGroup, ">=" , getIfmlCFrom());
            org.chocosolver.solver.constraints.Constraint toCstr = cs4model.sum(allFeaturesInGroup, "<=" , getIfmlCTo());
            String fromCstrName = "Cardinality '"+"["+getIfmlCFrom()+".."+getIfmlCTo()+"]"+"' for "+groupName+" "+fromCstr.toString();
            String toCstrName = "Cardinality '"+"["+getIfmlCFrom()+".."+getIfmlCTo()+"]"+"' for "+groupName+" "+toCstr.toString();
            fromCstr.setName(fromCstrName);
            toCstr.setName(toCstrName);
            cs.addConstraint(fromCstr);
            cs.addConstraint(toCstr);
        }
    }

    // EXPRESSIONS
    public org.chocosolver.solver.constraints.Constraint IfmlMExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
        return null;
    }
    public ArExpression IfmlMExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return null;
    }
    // EXP:VARS
    public org.chocosolver.solver.constraints.Constraint IfmlVariable.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(cs.getVar(getFullName()),"=",1);
    	cstr.setName(cstr.toString());
    	return cstr;
    }

    public ArExpression IfmlVariable.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return cs.getVar(getFullName());
    }

    // EXP:VALUES
    public org.chocosolver.solver.constraints.Constraint IfmlMValue.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = getValue().collectIfmlConstraints(cs,cs4model);
        return cstr;
    }
    public ArExpression IfmlMValue.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return getValue().collectArExpression(cs,cs4model);
    }
    public org.chocosolver.solver.constraints.Constraint Value.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	return null;
	}
    public ArExpression Value.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
    	return null;
	}

    public org.chocosolver.solver.constraints.Constraint BoolVal.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
        if (getValue()) {
        	org.chocosolver.solver.constraints.Constraint cstr = cs4model.trueConstraint();
        	cstr.setName("true");
            return cstr;
        }
        else {
        	org.chocosolver.solver.constraints.Constraint cstr = cs4model.falseConstraint();
        	cstr.setName("false");
            return cstr;
        }
    }
    public ArExpression IntVal.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return cs4model.intVar(getValue());
    }

    // EXP: AddExp
    public ArExpression IfmlMAddAddExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return getIfmlLeft().collectArExpression(cs,cs4model).add(getIfmlRight().collectArExpression(cs,cs4model));
    }
    public ArExpression IfmlMSubAddExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return getIfmlLeft().collectArExpression(cs,cs4model).sub(getIfmlRight().collectArExpression(cs,cs4model));
    }

    // EXP: MultExp
    // multiply
    public ArExpression IfmlMMultMultExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return getIfmlLeft().collectArExpression(cs,cs4model).mul(getIfmlRight().collectArExpression(cs,cs4model));
    }
    // division
    public ArExpression IfmlMDivMultExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return getIfmlLeft().collectArExpression(cs,cs4model).div(getIfmlRight().collectArExpression(cs,cs4model));
    }
    // mod
    public ArExpression IfmlMModMultExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
        return getIfmlLeft().collectArExpression(cs,cs4model).mod(getIfmlRight().collectArExpression(cs,cs4model));
    }

    // EXP: Unary
    public ArExpression IfmlMMinusExp.collectArExpression(ChocoSolverIfml cs, org.chocosolver.solver.Model cs4model) {
    	return getIfmlOperand().collectArExpression(cs,cs4model).neg();
    }
    public org.chocosolver.solver.constraints.Constraint IfmlMNegExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = cs4model.not(getIfmlOperand().collectIfmlConstraints(cs,cs4model));
    	cstr.setName("("+"not("+cstr.getName()+")"+")");
    	return cstr;
    }

    // EXP: EqualityExpr
    public org.chocosolver.solver.constraints.Constraint IfmlMEqExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
        // Need to type check JUST the equality of expressions, to know if the constraints should produce  '==' or '<->'.
        // All other type checking should be done after flattening.
    	checkIfmlType(IfmlTypes.BOOL, new SemanticConditionList());
        if (isInt) {
        	org.chocosolver.solver.constraints.Constraint cstr = getIfmlLeft().collectArExpression(cs,
        			cs4model).eq(getIfmlRight().collectArExpression(cs,cs4model)).decompose();
        	cstr.setName("("+cstr.toString()+")");
        	return cstr;
        	//decompose(), returns the topmost constraint representing the expression. 
        	//If needed, a call to this method creates additional variables and posts additional constraints.
        } else {//<-> ifOnlyIf constraint
        	org.chocosolver.solver.constraints.Constraint ifCstr = getIfmlLeft().collectIfmlConstraints(cs,cs4model);
        	org.chocosolver.solver.constraints.Constraint thenCstr = getIfmlRight().collectIfmlConstraints(cs,cs4model);
            BoolVar ifCstr_bool = ifCstr.reify();
            BoolVar thenCstr_bool = thenCstr.reify();
            org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(ifCstr_bool,"=", thenCstr_bool);
            cstr.setName("("+ifCstr.getName()+") <-> ("+thenCstr.getName()+")");
            return cstr;
        }
    }

    // EXP: RelationalExpr
    // >=
    public org.chocosolver.solver.constraints.Constraint IfmlMGTEQExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = getIfmlLeft().collectArExpression(cs,
    			cs4model).ge(getIfmlRight().collectArExpression(cs,cs4model)).decompose();
    	cstr.setName("("+cstr.toString()+")");
        return cstr;
    }
    // <=
    public org.chocosolver.solver.constraints.Constraint IfmlMLTEQExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = getIfmlLeft().collectArExpression(cs,
    			cs4model).le(getIfmlRight().collectArExpression(cs,cs4model)).decompose();
    	cstr.setName("("+cstr.toString()+")");
        return cstr;
    }
    // >
    public org.chocosolver.solver.constraints.Constraint IfmlMGTExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = getIfmlLeft().collectArExpression(cs,
    			cs4model).gt(getIfmlRight().collectArExpression(cs,cs4model)).decompose();
    	cstr.setName("("+cstr.toString()+")");
        return cstr;
    }
    // <
    public org.chocosolver.solver.constraints.Constraint IfmlMLTExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint cstr = getIfmlLeft().collectArExpression(cs,
    			cs4model).lt(getIfmlRight().collectArExpression(cs,cs4model)).decompose();
    	cstr.setName("("+cstr.toString()+")");
        return cstr;
    }

    // EXP: BoolExp
    // ifOnlyIf
    public org.chocosolver.solver.constraints.Constraint IfmlMEquivExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint ifCstr = getIfmlLeft().collectIfmlConstraints(cs,cs4model);
    	org.chocosolver.solver.constraints.Constraint thenCstr = getIfmlRight().collectIfmlConstraints(cs,cs4model);
        BoolVar ifCstr_bool = ifCstr.reify();
        BoolVar thenCstr_bool = thenCstr.reify();
        org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(ifCstr_bool,"=", thenCstr_bool);
        cstr.setName("("+ifCstr.getName()+") <-> ("+thenCstr.getName()+")");
        return cstr;
    }
    // ifThen
    public org.chocosolver.solver.constraints.Constraint IfmlMImpliesExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
    	org.chocosolver.solver.constraints.Constraint ifCstr = getIfmlLeft().collectIfmlConstraints(cs,cs4model);
    	org.chocosolver.solver.constraints.Constraint thenCstr = getIfmlRight().collectIfmlConstraints(cs,cs4model);
        BoolVar ifCstr_bool = ifCstr.reify();
        BoolVar thenCstr_bool = thenCstr.reify();
        org.chocosolver.solver.constraints.Constraint cstr = cs4model.arithm(ifCstr_bool,"<=", thenCstr_bool);
        cstr.setName("("+ifCstr.getName()+") -> ("+thenCstr.getName()+")");
        return cstr;
    }
    // or
    public org.chocosolver.solver.constraints.Constraint IfmlMOrBoolExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
        org.chocosolver.solver.constraints.Constraint leftCstr = getIfmlLeft().collectIfmlConstraints(cs,cs4model);
        org.chocosolver.solver.constraints.Constraint rightCstr = getIfmlRight().collectIfmlConstraints(cs,cs4model);
        org.chocosolver.solver.constraints.Constraint cstr = cs4model.or(leftCstr, rightCstr);
        cstr.setName("("+leftCstr.getName()+") \\/ ("+rightCstr.getName()+")");
        return cstr;
    }
    // and
    public org.chocosolver.solver.constraints.Constraint IfmlMAndBoolExp.collectIfmlConstraints(ChocoSolverIfml cs, 
    		org.chocosolver.solver.Model cs4model) {
        org.chocosolver.solver.constraints.Constraint leftCstr = getIfmlLeft().collectIfmlConstraints(cs,cs4model);
        org.chocosolver.solver.constraints.Constraint rightCstr = getIfmlRight().collectIfmlConstraints(cs,cs4model);
        org.chocosolver.solver.constraints.Constraint cstr = cs4model.and(leftCstr, rightCstr);
        cstr.setName("("+leftCstr.getName()+") /\\ ("+rightCstr.getName()+")");
        return cstr;
    }    
    
}