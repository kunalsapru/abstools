import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.analyser.*;
import abs.frontend.ifml.IfmlTypes;

/**
 * Checks whether features, groups and constraints are repeated.
 * Checks for type errors and repition errors in attribute declaration.
 * Check for valid variable declaration.
 **/

aspect IfmlErrorCheck {

    public void ASTNode.checkIfmlType(IfmlTypes type, SemanticConditionList c) {
        //    System.out.println("spreading check in constraint from...");
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).checkIfmlType(type,c);
    }

    //Check if same feature has been included in multiple groups
    public void CompilationUnit.collectErrors(SemanticConditionList c) {
    	super.collectErrors(c);
		if(hasIfmlGroupDecl()) {
    		ArrayList<String> featuresInGroupList = new ArrayList<String>();
    		for(int i = 0; i<getNumIfmlGroupDecl();i++){
    			IfmlGroupDecl ifmlGroupDecl = getIfmlGroupDecl(i);
    			for(int j=0;j<ifmlGroupDecl.getNumIfmlGroupDeclFeature();j++) {
    				String featureName = ifmlGroupDecl.getIfmlGroupDeclFeature(j).getIfmlFeatVar().getIfmlFName();
    				if(featuresInGroupList.contains(featureName)) {
    					//Show error - Same feature can't be part of multiple groups.
    					c.add(new SemanticError(this,ErrorMessage.SAME_FEATURE_IN_MULTIPLE_GROUPS,featureName,ifmlGroupDecl.getName()));
    				}
    				featuresInGroupList.add(featureName);
    			}
    		}
    	}
		//Checking same group for multiple cardinalities
		if(hasIfmlConstraintDecl()) {
			for(String groupName : ((Model)calcContextNode(Model.class)).ifmlgroups()) {
				ArrayList<IfmlCardinality> ifmlCardinalityList = new ArrayList<IfmlCardinality>();
				for(int i=0;i<getNumIfmlConstraintDecl();i++) {
					IfmlConstraintDecl ifmlConstraintDecl = getIfmlConstraintDecl(i);
					for(int j =0; j<ifmlConstraintDecl.getNumIfmlConstraintDeclGroupFeature();j++){
						IfmlConstraintDeclGroupFeature ifmlConstraintDeclGroupFeature = ifmlConstraintDecl.getIfmlConstraintDeclGroupFeature(j);
						if(ifmlConstraintDeclGroupFeature.getName().equals(groupName)){
							if(ifmlConstraintDeclGroupFeature.hasIfmlCard()){
								ifmlCardinalityList.add(ifmlConstraintDeclGroupFeature.getIfmlCard());
								if(ifmlCardinalityList.size() > 1) {
									IfmlCardinality ifmlCardinality = ifmlCardinalityList.get(0);
									String strCardinality = ifmlCardinality.getIfmlCardinalityPrettyName();
									String strCardinalityError = ifmlConstraintDeclGroupFeature.getIfmlCard().getIfmlCardinalityPrettyName();
									String iconstraintName = "";
									if(ifmlConstraintDecl.hasIfmlConsVar()) {
										iconstraintName = ifmlConstraintDecl.getIfmlConsVar().getIfmlCName();
									}
									c.add(new SemanticError(this,ErrorMessage.MULTIPLE_CARDINALITY_GROUP,
											strCardinalityError,groupName, iconstraintName, strCardinality));
								}
							}
						}
						
					}
				}
			}
		}

    }
    
	// Check if ifeature name is repeated
    public void IfmlFeatureDecl.collectErrors(SemanticConditionList c) {  
        super.collectErrors(c);
        // check if repeated feature
        if (java.util.Collections.frequency(((Model)calcContextNode(Model.class)).ifmlfeatures(), 
    			getName()) > 1 && isRepeated)
            c.add(new SemanticError(this,ErrorMessage.DUPLICATE_FEATURE,getName()));
		// check for attributes in feature and apply type check         
      	if(hasIfmlAttributes()) {
      		IfmlAttributes ifmlAttributes = getIfmlAttributes(); 
      		for(int i=0; i<ifmlAttributes.getNumIfmlAttribute(); i++) {
      			ifmlAttributes.getIfmlAttribute(i).checkIfmlType(IfmlTypes.BOOL,c);
      		}
      	}
    }

	// Check if igroup name is repeated
    public void IfmlGroupDecl.collectErrors(SemanticConditionList c) {  
        super.collectErrors(c);
        if (java.util.Collections.frequency(((Model)calcContextNode(Model.class)).ifmlgroups(), 
    			getName()) > 1 && isRepeated)
            c.add(new SemanticError(this,ErrorMessage.DUPLICATE_GROUP,getName()));
        // Check for same group and feature name. If a group name is already used as a feature, show an error
		if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(getName())) {
				c.add(new SemanticError(this,ErrorMessage.DUPLICATE_GROUP_FEATURE,getName()));
			}
        // Check if feature is declared or not, before adding to group
   		for(int i=0;i<getNumIfmlGroupDeclFeature();i++) {
   			String featureInGroup = getIfmlGroupDeclFeature(i).getIfmlFeatVar().getIfmlFName();
			if(!(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(featureInGroup))) {
				c.add(new SemanticError(this,ErrorMessage.UNDECLARED_FEATURE,featureInGroup,getName()));
			}
   		}
    }
    
	// Check if iconstraint name is repeated
    public void IfmlConstraintDecl.collectErrors(SemanticConditionList c) {  
        super.collectErrors(c);
        if(hasIfmlConsVar()) {
        	// Strangely, isRepeated does not work until we either print ifmlcontraints or use Collections.frequency method
            if (java.util.Collections.frequency(((Model)calcContextNode(Model.class)).ifmlconstraints(), 
        			getIfmlConsVar().getIfmlCName()) > 1 && isRepeated) {
            	c.add(new SemanticError(this,ErrorMessage.DUPLICATE_CONSTRAINT,getIfmlConsVar().getIfmlCName()));
            }// Check for same constraint and feature name. If a constraint name is already used as a feature, show an error.
            else if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(getIfmlConsVar().getIfmlCName())) {
    				c.add(new SemanticError(this,ErrorMessage.DUPLICATE_CONSTRAINT_FEATURE,getIfmlConsVar().getIfmlCName()));
			}
            // Check for same constraint and group name. If a constraint name is already used as a group, show an error.
            else if(((Model)calcContextNode(Model.class)).ifmlgroups().contains(getIfmlConsVar().getIfmlCName())) {
    				c.add(new SemanticError(this,ErrorMessage.DUPLICATE_CONSTRAINT_GROUP,getIfmlConsVar().getIfmlCName()));
    			}
        }
    }
    
    public void IfmlConstraintDeclGroupFeature.collectErrors(SemanticConditionList c){
    	super.collectErrors(c);
    	// Check if group/feature is declared or not, before adding to constraints
		String groupFeatureInConstraint = getName();
			
		if(!(((Model)calcContextNode(Model.class)).ifmlgroups().contains(groupFeatureInConstraint))) {
			//Not in group
			if(!(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(groupFeatureInConstraint))) {
			//Not in feature
				c.add(new SemanticError(this,ErrorMessage.UNDECLARED_GROUP_FEATURE_CONSTRAINT,groupFeatureInConstraint));
			} else if(hasIfmlCard()) {//Features can not have cardinality constraints.
				String strCardinality = getIfmlCard().getIfmlCardinalityPrettyName();
				c.add(new SemanticError(this,ErrorMessage.CONSTRAINT_FEATURE_CARDINALITY,groupFeatureInConstraint, strCardinality));
			}
		}
		//Check for valid features and expressions in ifml constraints.
		for(int j=0; j<getNumIfmlConstraint();j++) {
			IfmlConstraint ifmlConstraint = getIfmlConstraint(j);
			//checking types
			ifmlConstraint.checkIfmlType(IfmlTypes.BOOL,c);
			//Errors for IfmlIfIn/IfmlIfOut are shown while checking IfmlTypes
			if(ifmlConstraint instanceof IfmlExcludes){
				IfmlExcludes ifmlExcludes = (IfmlExcludes)(getIfmlConstraint(j));
				//Check if feature is valid or not
				for(int k=0;k<ifmlExcludes.getNumIfmlFeatVar();k++) {
		   			String featureInExcludes = ifmlExcludes.getIfmlFeatVar(k).getIfmlFName();
					if(!(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(featureInExcludes))) {
						c.add(new SemanticError(this,ErrorMessage.UNDECLARED_FEATURE_EXCLUDES,featureInExcludes,
								getName()));
					}
		   		}
			}
			if(ifmlConstraint instanceof IfmlRequires){
				IfmlRequires ifmlRequires = (IfmlRequires)(getIfmlConstraint(j));
				//Check if feature is valid or not
				for(int x=0;x<ifmlRequires.getNumIfmlFeatVar();x++) {
		   			String featureInRequires = ifmlRequires.getIfmlFeatVar(x).getIfmlFName();
					if(!(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(featureInRequires))) {
						c.add(new SemanticError(this,ErrorMessage.UNDECLARED_FEATURE_REQUIRES,featureInRequires,
								getName()));
					}
		   		}
			}
			//Check for opt constraint.
			if(ifmlConstraint instanceof IfmlOpt) {
				//Groups can not have 'opt' constraint
				if(((Model)calcContextNode(Model.class)).ifmlgroups().contains(getName())) {
					c.add(new SemanticError(this,ErrorMessage.OPTIONAL_CONSTRAINT_ERROR,getName()));
				}
				//If feature has 'opt' constraint, cardinality of it's group must be allof.
				if(((Model)calcContextNode(Model.class)).ifmlfeatures().contains(getName())) {
                    IfmlGroupDecl ifmlGroupDecl = ((Model)calcContextNode(Model.class)).getIfmlGroupDecl(getName());
                    IfmlCardinality ifmlCardinality = ifmlGroupDecl!=null ? 
                            ((Model)calcContextNode(Model.class)).getGroupCardinality(ifmlGroupDecl.getName()):null;
                    if(ifmlCardinality!=null && !(ifmlCardinality instanceof IfmlAllOf)) {
                        c.add(new SemanticError(this,ErrorMessage.OPTIONAL_CONSTRAINT_ERROR_FEATURE_ALLOF,
                        		getName(), ifmlGroupDecl.getName(), ifmlCardinality.getIfmlCardinalityPrettyName()));
                    }
                }

			}				
		}
    }


    // Check if attribute variable is already defined, and its type is well-formed.
    public void IfmlAttribute.collectErrors(SemanticConditionList c) {
        super.collectErrors(c);
        if(java.util.Collections.frequency(((Model)calcContextNode(Model.class)).ifmlattributes(), 
        			featureName()+"."+getName()) > 1 && isRepeated) {
        		c.add(new SemanticError(this, ErrorMessage.DUPLICATE_VARIABLE, featureName()+"."+getName()));
        }
        this.getIfmlAType().collectErrors(c);
    }

    public void IfmlUnresolvedMType.collectErrors(SemanticConditionList c) {
        c.add(new SemanticError(this, ErrorMessage.UNKNOWN_ATTRIBUTE_TYPE,
                this.getTypename()));
    }
    public void IfmlBoolMType.collectErrors(SemanticConditionList c) {
        if (!(this.getTypename().equals("Bool"))) {
            c.add(new SemanticError(this, ErrorMessage.UNEXPECTED_ATTRIBUTE_TYPE,
                    this.getTypename(), "Bool"));
        }
    }
    public void IfmlStringMType.collectErrors(SemanticConditionList c) {
        if (!(this.getTypename().equals("String"))) {
            c.add(new SemanticError(this, ErrorMessage.UNEXPECTED_ATTRIBUTE_TYPE,
                    this.getTypename(), "String"));
        }
    }
    public void IfmlIntMType.collectErrors(SemanticConditionList c) {
        if (!(this.getTypename().equals("Int"))) {
            c.add(new SemanticError(this, ErrorMessage.UNEXPECTED_ATTRIBUTE_TYPE,
                    this.getTypename(), "Int"));
        }
    }
    public void IfmlIntListMType.collectErrors(SemanticConditionList c) {
        if (!(this.getTypename().equals("Int"))) {
            c.add(new SemanticError(this, ErrorMessage.UNEXPECTED_ATTRIBUTE_TYPE,
                    this.getTypename(), "Int"));
        }
    }


    // type of negation
    public void IfmlMNegExp.checkIfmlType(IfmlTypes type,SemanticConditionList c) {
        super.checkIfmlType(IfmlTypes.BOOL,c);
        //getOperand().checkType(Types.BOOL,c);
        if (type != IfmlTypes.BOOL)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_BOOL,"NEGATION"));
    }
    // type of negative sign
    public void IfmlMMinusExp.checkIfmlType(IfmlTypes type,SemanticConditionList c) {
        super.checkIfmlType(IfmlTypes.INT,c);
        if (type != IfmlTypes.INT)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_INT,"NEGATIVE"));
    }
    // check type of values
    public void IntVal.checkIfmlType(IfmlTypes type,SemanticConditionList c) {
        if (type != IfmlTypes.INT)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_INT,""+getValue()));
    }
    public void BoolVal.checkIfmlType(IfmlTypes type,SemanticConditionList c) {
        if (type != IfmlTypes.BOOL)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_BOOL,""+getValue()));
    }
    // check type of boolean operators
    public void IfmlMBoolExp.checkIfmlType(IfmlTypes type, SemanticConditionList c) {
        super.checkIfmlType(IfmlTypes.BOOL,c);
        if (type != IfmlTypes.BOOL)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_BOOL,toString()));
    }
    // check type of int relations
    public void IfmlMRelationalExpr.checkIfmlType(IfmlTypes type, SemanticConditionList c) {
        super.checkIfmlType(IfmlTypes.INT,c);
        if (type != IfmlTypes.BOOL)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_BOOL,toString()));
    }
    // check type of equality operators (assuming boolean or int)
    public boolean IfmlMEqualityExpr.isInt  = false;
    public boolean IfmlMEqualityExpr.isBool = false;
    public void IfmlMEqualityExpr.checkIfmlType(IfmlTypes type, SemanticConditionList c) {
        SemanticConditionList lint  = new SemanticConditionList();
        SemanticConditionList lbool = new SemanticConditionList();
        // TODO: use getLeft().isIntType() instead if possible
        getIfmlLeft().checkIfmlType(IfmlTypes.INT,lint);
        if (!lint.containsErrors()) {
            isInt = true;
            getIfmlRight().checkIfmlType(IfmlTypes.INT,c);
        }
        else {
            isBool = true;
            getIfmlLeft().checkIfmlType(IfmlTypes.BOOL,c);
            getIfmlRight().checkIfmlType(IfmlTypes.BOOL,c);
        }
    }
    //check type of arithmetic expressions
    public void IfmlMArithmeticExpr.checkIfmlType(IfmlTypes type, SemanticConditionList c) {
        super.checkIfmlType(IfmlTypes.INT,c);
        if (type != IfmlTypes.INT)
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_INT,toString()));
    }

    // type of variables
    public void IfmlVariable.checkIfmlType(IfmlTypes type, SemanticConditionList c) {
        if (!isBool() && !isInt()) {
            c.add(new SemanticError(this,ErrorMessage.UNDECLARED_VARIABLE,getFullName()));
        }
        else if(isBool() && type!=IfmlTypes.BOOL) 
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_BOOL,getFullName()));
        else if(isInt() && type!=IfmlTypes.INT) 
            c.add(new SemanticError(this,ErrorMessage.EXPECTED_INT,getFullName()));
    }



}
// Local Variables:
// mode: java
// End:
